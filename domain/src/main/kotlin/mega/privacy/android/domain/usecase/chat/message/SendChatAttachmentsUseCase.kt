package mega.privacy.android.domain.usecase.chat.message

import kotlinx.coroutines.flow.emitAll
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.merge
import mega.privacy.android.domain.usecase.file.GetFileFromUriUseCase
import mega.privacy.android.domain.usecase.transfers.chatuploads.StartChatUploadsWithWorkerUseCase
import javax.inject.Inject

/**
 * Begin uploading files to later attach them to a chat. It also generates a pending message to represent this attachment in the chat while it's being uploaded.
 */
class SendChatAttachmentsUseCase @Inject constructor(
    private val startChatUploadsWithWorkerUseCase: StartChatUploadsWithWorkerUseCase,
    private val getFileFromUriUseCase: GetFileFromUriUseCase,
) {
    /**
     * Invoke
     *
     * @param chatId the id of the chat where these files will be attached
     * @param uris String representation of the files,
     */
    operator fun invoke(chatId: Long, uris: List<String>) =
        flow {
            emitAll(
                //each file is sent as a single message in parallel
                uris
                    .mapNotNull { uriString ->
                        getFileFromUriUseCase(uriString, CHAT_TEMPORARY_FOLDER)
                    }
                    .map { file ->
                        //a pending message should be added to the pagination in future tasks and this id will come from it (autogenerated db id?)
                        val pendingMessageId = chatId + testIdGenerator
                        testIdGenerator--
                        startChatUploadsWithWorkerUseCase(listOf(file), pendingMessageId)
                    }.merge()
            )
        }

    private var testIdGenerator = -1L
}

private const val CHAT_TEMPORARY_FOLDER = "chatTempMEGA"